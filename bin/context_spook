#!/usr/bin/env ruby

require 'context_spook'
require 'tins/go'
include Tins::GO
require 'json'
require 'pathname'

# The usage method displays the command-line interface help text and example
# usage patterns for the ContextSpook tool.
#
# This method outputs a formatted help message that includes the tool's usage
# syntax, available options, and practical examples.
#
# @see ContextSpook::generate_context
# @see ContextSpook::Generator
# @see ContextSpook::Generator::Context
def usage
  puts <<~EOT

  Usage: #{File.basename($0)} [options] <context_definition_file>

  Options:
    -o FILE      Write output to FILE instead of stdout
    ~v           Disable verbose output, enabled by default
    -h           Show this help message
    -d DIR[:SFX] Directory to search for files (can be used multiple times),
                 if SFX is given will only consider files with this suffix,
                 otherwise the -s argument value is used.
    -s SUFFIX    File suffix to include, defaults to all

  Examples:
    # Generate context and output to stdout
    #{File.basename($0)} .contexts/project.rb

    # Generate context from directory globs
    #{File.basename($0)} -d lib -d spec -s rb

    # Generate context without verbose output
    #{File.basename($0)} .contexts/project.rb ~v

    # Generate context and save to file
    #{File.basename($0)} .contexts/project.rb -o context.json

    # Generate context from directory globs and save to file
    #{File.basename($0)} -d lib -d spec -s rb -o context.json

    # Generate context with explicit suffix hints
    # -d lib:rb collects only .rb files from lib/
    # -d bin:all collects all files from bin/ (no suffix filtering)
    #{File.basename($0)} -d lib:rb -d bin:all

    # Same result using default -s suffix all
    #{File.basename($0)} -d lib:rb -d bin
  EOT
  exit 0
end

opts    = go 'd:s:o:pvh', defaults: { ?v => true, ?s => 'all' }
opts[?h] and usage
context = nil
output  = nil
if opts[?d]
  suffix_arg = opts[?s]
  context = ContextSpook.generate_context(verbose: opts[?v]) do
    context do
      dirs_sfx = opts[?d].to_a.map { |d| d =~ /:/ ? d : "#{d}:#{suffix_arg}" }
      dirs_sfx.each do |ds|
        dir, suffix = ds.split(?:, 2)
        dir = Pathname.new(dir).expand_path
        dir_glob = dir + (suffix == 'all' ? '**/*' : "**/*.#{suffix}")
        Dir[dir_glob].each do |filename|
          Pathname.new(filename).file? or next
          file filename
        end
      end
    end
  end
else
  filename = ARGV.shift or fail 'require context definition file as an argument'
  context = ContextSpook.generate_context(filename, verbose: opts[?v])
end
if output_filename = opts[?o]
  if File.exist?(output_filename)
    fail "Filename #{output_filename.inspect} already exists!"
  end
  output = File.new output_filename, ?w
else
  output = STDOUT
end
JSON.dump(context.as_json, output)
