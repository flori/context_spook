#!/usr/bin/env ruby

require 'context_spook'
require 'tins/go'
include Tins::GO
require 'json'
require 'pathname'

# The usage method displays the command-line interface help text and example
# usage patterns for the ContextSpook tool.
#
# This method outputs a formatted help message that includes the tool's usage
# syntax, available options, and practical examples.
#
# @see ContextSpook::generate_context
# @see ContextSpook::Generator
# @see ContextSpook::Generator::Context
def usage
  puts <<~EOT

  Usage: #{File.basename($0)} [options] <context_definition_file>

  Options:
    -o FILE    Write output to FILE instead of stdout
    -v         Verbose output (default), disable with ~v
    -h         Show this help message
    -d DIR     Directory to search for files (defaults to current dir, can be
               used multiple times)
    -s SUFFIX  File suffix to include (can be used multiple times)

  Examples:
    # Generate context and output to stdout
    #{File.basename($0)} .contexts/project.rb

    # Generate context from directory globs
    #{File.basename($0)} -d lib -d spec -s rb

    # Generate context with verbose output
    #{File.basename($0)} .contexts/project.rb -v

    # Generate context from directory globs with verbose output
    #{File.basename($0)} -d lib -d spec -s rb -v

    # Generate context and save to file
    #{File.basename($0)} .contexts/project.rb -o context.json

    # Generate context from directory globs and save to file
    #{File.basename($0)} -d lib -d spec -s rb -o context.json

  EOT
  exit 0
end

opts    = go 'd:s:o:pvh', defaults: { ?d => ?., ?v => true }
opts[?h] and usage
context = nil
output  = nil
if opts[?s]
  context = ContextSpook.generate_context(verbose: opts[?v]) do
    context do
      opts[?d].to_a.each do |d|
        dir = Pathname.new(d).expand_path
        opts[?s].to_a.each do |suffix|
          dir_glob = dir + "**/*.#{suffix}"
          Dir[dir_glob].each do |filename|
            file filename
          end
        end
      end
    end
  end
else
filename = ARGV.shift or fail 'require context definition file as an argument'
  context = ContextSpook.generate_context(filename, verbose: opts[?v])
end
if output_filename = opts[?o]
  if File.exist?(output_filename)
    fail "Filename #{output_filename.inspect} already exists!"
  end
  output = File.new output_filename, ?w
else
  output = STDOUT
end
JSON.dump(context.as_json, output)
